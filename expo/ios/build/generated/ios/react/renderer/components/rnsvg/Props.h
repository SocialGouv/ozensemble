
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <react/renderer/graphics/Color.h>
#include <react/renderer/imagemanager/primitives.h>
#include <vector>

namespace facebook::react {

struct RNSVGSvgViewAndroidNativeBackgroundAndroidStruct {
  std::string type{};
  Float color{0.0};
  bool borderless{false};
  Float rippleRadius{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGSvgViewAndroidNativeBackgroundAndroidStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_color = map.find("color");
  if (tmp_color != map.end()) {
    fromRawValue(context, tmp_color->second, result.color);
  }
  auto tmp_borderless = map.find("borderless");
  if (tmp_borderless != map.end()) {
    fromRawValue(context, tmp_borderless->second, result.borderless);
  }
  auto tmp_rippleRadius = map.find("rippleRadius");
  if (tmp_rippleRadius != map.end()) {
    fromRawValue(context, tmp_rippleRadius->second, result.rippleRadius);
  }
}

static inline std::string toString(const RNSVGSvgViewAndroidNativeBackgroundAndroidStruct &value) {
  return "[Object RNSVGSvgViewAndroidNativeBackgroundAndroidStruct]";
}

struct RNSVGSvgViewAndroidNativeForegroundAndroidStruct {
  std::string type{};
  Float color{0.0};
  bool borderless{false};
  Float rippleRadius{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGSvgViewAndroidNativeForegroundAndroidStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_color = map.find("color");
  if (tmp_color != map.end()) {
    fromRawValue(context, tmp_color->second, result.color);
  }
  auto tmp_borderless = map.find("borderless");
  if (tmp_borderless != map.end()) {
    fromRawValue(context, tmp_borderless->second, result.borderless);
  }
  auto tmp_rippleRadius = map.find("rippleRadius");
  if (tmp_rippleRadius != map.end()) {
    fromRawValue(context, tmp_rippleRadius->second, result.rippleRadius);
  }
}

static inline std::string toString(const RNSVGSvgViewAndroidNativeForegroundAndroidStruct &value) {
  return "[Object RNSVGSvgViewAndroidNativeForegroundAndroidStruct]";
}

struct RNSVGSvgViewAndroidHitSlopStruct {
  Float left{0.0};
  Float top{0.0};
  Float right{0.0};
  Float bottom{0.0};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGSvgViewAndroidHitSlopStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_left = map.find("left");
  if (tmp_left != map.end()) {
    fromRawValue(context, tmp_left->second, result.left);
  }
  auto tmp_top = map.find("top");
  if (tmp_top != map.end()) {
    fromRawValue(context, tmp_top->second, result.top);
  }
  auto tmp_right = map.find("right");
  if (tmp_right != map.end()) {
    fromRawValue(context, tmp_right->second, result.right);
  }
  auto tmp_bottom = map.find("bottom");
  if (tmp_bottom != map.end()) {
    fromRawValue(context, tmp_bottom->second, result.bottom);
  }
}

static inline std::string toString(const RNSVGSvgViewAndroidHitSlopStruct &value) {
  return "[Object RNSVGSvgViewAndroidHitSlopStruct]";
}
class RNSVGSvgViewAndroidProps final : public ViewProps {
 public:
  RNSVGSvgViewAndroidProps() = default;
  RNSVGSvgViewAndroidProps(const PropsParserContext& context, const RNSVGSvgViewAndroidProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  folly::dynamic bbWidth{};
  folly::dynamic bbHeight{};
  Float minX{0.0};
  Float minY{0.0};
  Float vbWidth{0.0};
  Float vbHeight{0.0};
  std::string align{};
  int meetOrSlice{0};
  SharedColor tintColor{};
  SharedColor color{};
  std::string pointerEvents{};
  bool hasTVPreferredFocus{false};
  Float borderTopEndRadius{0.0};
  Float borderBottomStartRadius{0.0};
  SharedColor borderBottomColor{};
  int nextFocusDown{0};
  SharedColor borderRightColor{};
  int nextFocusRight{0};
  SharedColor borderLeftColor{};
  SharedColor borderColor{};
  bool removeClippedSubviews{false};
  int nextFocusForward{0};
  int nextFocusUp{0};
  bool accessible{false};
  SharedColor borderStartColor{};
  Float borderBottomEndRadius{0.0};
  SharedColor borderEndColor{};
  bool focusable{false};
  RNSVGSvgViewAndroidNativeBackgroundAndroidStruct nativeBackgroundAndroid{};
  Float borderTopStartRadius{0.0};
  RNSVGSvgViewAndroidNativeForegroundAndroidStruct nativeForegroundAndroid{};
  std::string backfaceVisibility{};
  std::string borderStyle{};
  bool needsOffscreenAlphaCompositing{false};
  RNSVGSvgViewAndroidHitSlopStruct hitSlop{};
  SharedColor borderTopColor{};
  int nextFocusLeft{0};
  double borderTopRightRadius{0.0};
  double borderBottomRightRadius{0.0};
  double borderRadius{0.0};
  double borderBottomLeftRadius{0.0};
  double borderTopLeftRadius{0.0};
};

struct RNSVGCircleFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGCircleFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGCircleFillStruct &value) {
  return "[Object RNSVGCircleFillStruct]";
}

struct RNSVGCircleStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGCircleStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGCircleStrokeStruct &value) {
  return "[Object RNSVGCircleStrokeStruct]";
}
class RNSVGCircleProps final : public ViewProps {
 public:
  RNSVGCircleProps() = default;
  RNSVGCircleProps(const PropsParserContext& context, const RNSVGCircleProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGCircleFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGCircleStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic cx{};
  folly::dynamic cy{};
  folly::dynamic r{};
};

struct RNSVGClipPathFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGClipPathFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGClipPathFillStruct &value) {
  return "[Object RNSVGClipPathFillStruct]";
}

struct RNSVGClipPathStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGClipPathStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGClipPathStrokeStruct &value) {
  return "[Object RNSVGClipPathStrokeStruct]";
}
class RNSVGClipPathProps final : public ViewProps {
 public:
  RNSVGClipPathProps() = default;
  RNSVGClipPathProps(const PropsParserContext& context, const RNSVGClipPathProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGClipPathFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGClipPathStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic fontSize{};
  folly::dynamic fontWeight{};
  folly::dynamic font{};
};

class RNSVGDefsProps final : public ViewProps {
 public:
  RNSVGDefsProps() = default;
  RNSVGDefsProps(const PropsParserContext& context, const RNSVGDefsProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
};

struct RNSVGEllipseFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGEllipseFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGEllipseFillStruct &value) {
  return "[Object RNSVGEllipseFillStruct]";
}

struct RNSVGEllipseStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGEllipseStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGEllipseStrokeStruct &value) {
  return "[Object RNSVGEllipseStrokeStruct]";
}
class RNSVGEllipseProps final : public ViewProps {
 public:
  RNSVGEllipseProps() = default;
  RNSVGEllipseProps(const PropsParserContext& context, const RNSVGEllipseProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGEllipseFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGEllipseStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic cx{};
  folly::dynamic cy{};
  folly::dynamic rx{};
  folly::dynamic ry{};
};

struct RNSVGForeignObjectFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGForeignObjectFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGForeignObjectFillStruct &value) {
  return "[Object RNSVGForeignObjectFillStruct]";
}

struct RNSVGForeignObjectStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGForeignObjectStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGForeignObjectStrokeStruct &value) {
  return "[Object RNSVGForeignObjectStrokeStruct]";
}
class RNSVGForeignObjectProps final : public ViewProps {
 public:
  RNSVGForeignObjectProps() = default;
  RNSVGForeignObjectProps(const PropsParserContext& context, const RNSVGForeignObjectProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGForeignObjectFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGForeignObjectStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic fontSize{};
  folly::dynamic fontWeight{};
  folly::dynamic font{};
  folly::dynamic x{};
  folly::dynamic y{};
  folly::dynamic height{};
  folly::dynamic width{};
};

struct RNSVGGroupFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGGroupFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGGroupFillStruct &value) {
  return "[Object RNSVGGroupFillStruct]";
}

struct RNSVGGroupStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGGroupStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGGroupStrokeStruct &value) {
  return "[Object RNSVGGroupStrokeStruct]";
}
class RNSVGGroupProps final : public ViewProps {
 public:
  RNSVGGroupProps() = default;
  RNSVGGroupProps(const PropsParserContext& context, const RNSVGGroupProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGGroupFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGGroupStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic fontSize{};
  folly::dynamic fontWeight{};
  folly::dynamic font{};
};

struct RNSVGImageFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGImageFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGImageFillStruct &value) {
  return "[Object RNSVGImageFillStruct]";
}

struct RNSVGImageStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGImageStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGImageStrokeStruct &value) {
  return "[Object RNSVGImageStrokeStruct]";
}
class RNSVGImageProps final : public ViewProps {
 public:
  RNSVGImageProps() = default;
  RNSVGImageProps(const PropsParserContext& context, const RNSVGImageProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGImageFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGImageStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic x{};
  folly::dynamic y{};
  folly::dynamic width{};
  folly::dynamic height{};
  ImageSource src{};
  std::string align{};
  int meetOrSlice{0};
};

class RNSVGSvgViewProps final : public ViewProps {
 public:
  RNSVGSvgViewProps() = default;
  RNSVGSvgViewProps(const PropsParserContext& context, const RNSVGSvgViewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  folly::dynamic bbWidth{};
  folly::dynamic bbHeight{};
  Float minX{0.0};
  Float minY{0.0};
  Float vbWidth{0.0};
  Float vbHeight{0.0};
  std::string align{};
  int meetOrSlice{0};
  SharedColor tintColor{};
  SharedColor color{};
  std::string pointerEvents{};
};

class RNSVGLinearGradientProps final : public ViewProps {
 public:
  RNSVGLinearGradientProps() = default;
  RNSVGLinearGradientProps(const PropsParserContext& context, const RNSVGLinearGradientProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  folly::dynamic x1{};
  folly::dynamic y1{};
  folly::dynamic x2{};
  folly::dynamic y2{};
  std::vector<Float> gradient{};
  int gradientUnits{0};
  std::vector<Float> gradientTransform{};
};

struct RNSVGLineFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGLineFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGLineFillStruct &value) {
  return "[Object RNSVGLineFillStruct]";
}

struct RNSVGLineStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGLineStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGLineStrokeStruct &value) {
  return "[Object RNSVGLineStrokeStruct]";
}
class RNSVGLineProps final : public ViewProps {
 public:
  RNSVGLineProps() = default;
  RNSVGLineProps(const PropsParserContext& context, const RNSVGLineProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGLineFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGLineStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic x1{};
  folly::dynamic y1{};
  folly::dynamic x2{};
  folly::dynamic y2{};
};

struct RNSVGMarkerFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGMarkerFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGMarkerFillStruct &value) {
  return "[Object RNSVGMarkerFillStruct]";
}

struct RNSVGMarkerStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGMarkerStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGMarkerStrokeStruct &value) {
  return "[Object RNSVGMarkerStrokeStruct]";
}
class RNSVGMarkerProps final : public ViewProps {
 public:
  RNSVGMarkerProps() = default;
  RNSVGMarkerProps(const PropsParserContext& context, const RNSVGMarkerProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGMarkerFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGMarkerStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic fontSize{};
  folly::dynamic fontWeight{};
  folly::dynamic font{};
  folly::dynamic refX{};
  folly::dynamic refY{};
  folly::dynamic markerHeight{};
  folly::dynamic markerWidth{};
  std::string markerUnits{};
  std::string orient{};
  Float minX{0.0};
  Float minY{0.0};
  Float vbWidth{0.0};
  Float vbHeight{0.0};
  std::string align{};
  int meetOrSlice{0};
};

struct RNSVGMaskFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGMaskFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGMaskFillStruct &value) {
  return "[Object RNSVGMaskFillStruct]";
}

struct RNSVGMaskStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGMaskStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGMaskStrokeStruct &value) {
  return "[Object RNSVGMaskStrokeStruct]";
}
class RNSVGMaskProps final : public ViewProps {
 public:
  RNSVGMaskProps() = default;
  RNSVGMaskProps(const PropsParserContext& context, const RNSVGMaskProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGMaskFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGMaskStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic fontSize{};
  folly::dynamic fontWeight{};
  folly::dynamic font{};
  folly::dynamic x{};
  folly::dynamic y{};
  folly::dynamic height{};
  folly::dynamic width{};
  int maskUnits{0};
  int maskContentUnits{0};
};

struct RNSVGPathFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGPathFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGPathFillStruct &value) {
  return "[Object RNSVGPathFillStruct]";
}

struct RNSVGPathStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGPathStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGPathStrokeStruct &value) {
  return "[Object RNSVGPathStrokeStruct]";
}
class RNSVGPathProps final : public ViewProps {
 public:
  RNSVGPathProps() = default;
  RNSVGPathProps(const PropsParserContext& context, const RNSVGPathProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGPathFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGPathStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string d{};
};

struct RNSVGPatternFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGPatternFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGPatternFillStruct &value) {
  return "[Object RNSVGPatternFillStruct]";
}

struct RNSVGPatternStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGPatternStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGPatternStrokeStruct &value) {
  return "[Object RNSVGPatternStrokeStruct]";
}
class RNSVGPatternProps final : public ViewProps {
 public:
  RNSVGPatternProps() = default;
  RNSVGPatternProps(const PropsParserContext& context, const RNSVGPatternProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGPatternFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGPatternStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic fontSize{};
  folly::dynamic fontWeight{};
  folly::dynamic font{};
  folly::dynamic x{};
  folly::dynamic y{};
  folly::dynamic height{};
  folly::dynamic width{};
  int patternUnits{0};
  int patternContentUnits{0};
  std::vector<Float> patternTransform{};
  Float minX{0.0};
  Float minY{0.0};
  Float vbWidth{0.0};
  Float vbHeight{0.0};
  std::string align{};
  int meetOrSlice{0};
};

class RNSVGRadialGradientProps final : public ViewProps {
 public:
  RNSVGRadialGradientProps() = default;
  RNSVGRadialGradientProps(const PropsParserContext& context, const RNSVGRadialGradientProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  folly::dynamic fx{};
  folly::dynamic fy{};
  folly::dynamic cx{};
  folly::dynamic cy{};
  folly::dynamic rx{};
  folly::dynamic ry{};
  std::vector<Float> gradient{};
  int gradientUnits{0};
  std::vector<Float> gradientTransform{};
};

struct RNSVGRectFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGRectFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGRectFillStruct &value) {
  return "[Object RNSVGRectFillStruct]";
}

struct RNSVGRectStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGRectStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGRectStrokeStruct &value) {
  return "[Object RNSVGRectStrokeStruct]";
}
class RNSVGRectProps final : public ViewProps {
 public:
  RNSVGRectProps() = default;
  RNSVGRectProps(const PropsParserContext& context, const RNSVGRectProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGRectFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGRectStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic x{};
  folly::dynamic y{};
  folly::dynamic height{};
  folly::dynamic width{};
  folly::dynamic rx{};
  folly::dynamic ry{};
};

struct RNSVGSymbolFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGSymbolFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGSymbolFillStruct &value) {
  return "[Object RNSVGSymbolFillStruct]";
}

struct RNSVGSymbolStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGSymbolStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGSymbolStrokeStruct &value) {
  return "[Object RNSVGSymbolStrokeStruct]";
}
class RNSVGSymbolProps final : public ViewProps {
 public:
  RNSVGSymbolProps() = default;
  RNSVGSymbolProps(const PropsParserContext& context, const RNSVGSymbolProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGSymbolFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGSymbolStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic fontSize{};
  folly::dynamic fontWeight{};
  folly::dynamic font{};
  Float minX{0.0};
  Float minY{0.0};
  Float vbWidth{0.0};
  Float vbHeight{0.0};
  std::string align{};
  int meetOrSlice{0};
};

struct RNSVGTextFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGTextFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGTextFillStruct &value) {
  return "[Object RNSVGTextFillStruct]";
}

struct RNSVGTextStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGTextStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGTextStrokeStruct &value) {
  return "[Object RNSVGTextStrokeStruct]";
}
class RNSVGTextProps final : public ViewProps {
 public:
  RNSVGTextProps() = default;
  RNSVGTextProps(const PropsParserContext& context, const RNSVGTextProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGTextFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGTextStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic fontSize{};
  folly::dynamic fontWeight{};
  folly::dynamic font{};
  folly::dynamic dx{};
  folly::dynamic dy{};
  folly::dynamic x{};
  folly::dynamic y{};
  folly::dynamic rotate{};
  folly::dynamic inlineSize{};
  folly::dynamic textLength{};
  folly::dynamic baselineShift{};
  std::string lengthAdjust{};
  std::string alignmentBaseline{};
  folly::dynamic verticalAlign{};
};

struct RNSVGTextPathFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGTextPathFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGTextPathFillStruct &value) {
  return "[Object RNSVGTextPathFillStruct]";
}

struct RNSVGTextPathStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGTextPathStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGTextPathStrokeStruct &value) {
  return "[Object RNSVGTextPathStrokeStruct]";
}
class RNSVGTextPathProps final : public ViewProps {
 public:
  RNSVGTextPathProps() = default;
  RNSVGTextPathProps(const PropsParserContext& context, const RNSVGTextPathProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGTextPathFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGTextPathStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic fontSize{};
  folly::dynamic fontWeight{};
  folly::dynamic font{};
  folly::dynamic dx{};
  folly::dynamic dy{};
  folly::dynamic x{};
  folly::dynamic y{};
  folly::dynamic rotate{};
  folly::dynamic inlineSize{};
  folly::dynamic textLength{};
  folly::dynamic baselineShift{};
  std::string lengthAdjust{};
  std::string alignmentBaseline{};
  folly::dynamic verticalAlign{};
  std::string href{};
  std::string side{};
  std::string method{};
  std::string midLine{};
  std::string spacing{};
  folly::dynamic startOffset{};
};

struct RNSVGTSpanFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGTSpanFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGTSpanFillStruct &value) {
  return "[Object RNSVGTSpanFillStruct]";
}

struct RNSVGTSpanStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGTSpanStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGTSpanStrokeStruct &value) {
  return "[Object RNSVGTSpanStrokeStruct]";
}
class RNSVGTSpanProps final : public ViewProps {
 public:
  RNSVGTSpanProps() = default;
  RNSVGTSpanProps(const PropsParserContext& context, const RNSVGTSpanProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGTSpanFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGTSpanStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  folly::dynamic fontSize{};
  folly::dynamic fontWeight{};
  folly::dynamic font{};
  folly::dynamic dx{};
  folly::dynamic dy{};
  folly::dynamic x{};
  folly::dynamic y{};
  folly::dynamic rotate{};
  folly::dynamic inlineSize{};
  folly::dynamic textLength{};
  folly::dynamic baselineShift{};
  std::string lengthAdjust{};
  std::string alignmentBaseline{};
  folly::dynamic verticalAlign{};
  std::string content{};
};

struct RNSVGUseFillStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGUseFillStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGUseFillStruct &value) {
  return "[Object RNSVGUseFillStruct]";
}

struct RNSVGUseStrokeStruct {
  int type{-1};
  SharedColor payload{};
  std::string brushRef{};
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNSVGUseStrokeStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_type = map.find("type");
  if (tmp_type != map.end()) {
    fromRawValue(context, tmp_type->second, result.type);
  }
  auto tmp_payload = map.find("payload");
  if (tmp_payload != map.end()) {
    fromRawValue(context, tmp_payload->second, result.payload);
  }
  auto tmp_brushRef = map.find("brushRef");
  if (tmp_brushRef != map.end()) {
    fromRawValue(context, tmp_brushRef->second, result.brushRef);
  }
}

static inline std::string toString(const RNSVGUseStrokeStruct &value) {
  return "[Object RNSVGUseStrokeStruct]";
}
class RNSVGUseProps final : public ViewProps {
 public:
  RNSVGUseProps() = default;
  RNSVGUseProps(const PropsParserContext& context, const RNSVGUseProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  std::string name{};
  Float opacity{1.0};
  std::vector<Float> matrix{};
  std::string mask{};
  std::string markerStart{};
  std::string markerMid{};
  std::string markerEnd{};
  std::string clipPath{};
  int clipRule{0};
  bool responsible{false};
  std::string display{};
  std::string pointerEvents{};
  RNSVGUseFillStruct fill{};
  Float fillOpacity{1.0};
  int fillRule{1};
  RNSVGUseStrokeStruct stroke{};
  Float strokeOpacity{1.0};
  folly::dynamic strokeWidth{};
  int strokeLinecap{0};
  int strokeLinejoin{0};
  folly::dynamic strokeDasharray{};
  Float strokeDashoffset{0.0};
  Float strokeMiterlimit{0.0};
  int vectorEffect{0};
  std::vector<std::string> propList{};
  std::string href{};
  folly::dynamic x{};
  folly::dynamic y{};
  folly::dynamic height{};
  folly::dynamic width{};
};

} // namespace facebook::react
